"""Paper Review"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/sketching_gestalt_space.ipynb.

# %% auto 0
__all__ = ['generate_cube_grid', 'generate_custom_scene', 'create_group_aabb', 'group_by_proximity', 'compute_group_regularity']

# %% ../nbs/sketching_gestalt_space.ipynb 4
import matplotlib.pyplot as plt
import numpy as np
import open3d as o3d
import copy
import random

# %% ../nbs/sketching_gestalt_space.ipynb 11
# Generate a simple scene with cube primitives in structured arrangement
def generate_cube_grid(n_x=4, n_y=3, spacing=1.5):
    cube = o3d.geometry.TriangleMesh.create_box(width=1.0, height=1.0, depth=1.0)
    cube.compute_vertex_normals()
    scene = []
    for i in range(n_x):
        for j in range(n_y):
            new_cube = copy.deepcopy(cube)
            new_cube.translate(np.array([i * spacing, j * spacing, 0]))
            scene.append(new_cube)
    return scene

# %% ../nbs/sketching_gestalt_space.ipynb 12
def generate_custom_scene():
    cube = o3d.geometry.TriangleMesh.create_box(width=1.0, height=1.0, depth=1.0)
    cube.compute_vertex_normals()
    scene = []

    def place_grid(start, nx, ny, dx=1.5, dy=1.5):
        for i in range(nx):
            for j in range(ny):
                c = copy.deepcopy(cube)
                c.translate([start[0] + i * dx, start[1] + j * dy, start[2]])
                scene.append(c)

    def place_line(start, count, d=1.5):
        for i in range(count):
            c = copy.deepcopy(cube)
            c.translate([start[0] + i * d, start[1], start[2]])
            scene.append(c)

    def place_cluster(center, count=6, spread=0.6):
        for _ in range(count):
            c = copy.deepcopy(cube)
            offset = np.random.normal(scale=spread, size=3)
            c.translate(center + offset)
            scene.append(c)

    # Pattern 1: Structured Grid → suggests regularity and proximity
    place_grid(start=np.array([0, 0, 0]), nx=3, ny=2)

    # Pattern 2: Line → suggests continuity
    place_line(start=np.array([7, 0, 0]), count=5)

    # Pattern 3: Dense Cluster → suggests proximity, but low regularity
    place_cluster(center=np.array([0, 6, 0]), count=7)

    # Pattern 4: Small tight grid → proximity + potential symmetry
    place_grid(start=np.array([7, 6, 0]), nx=2, ny=2, dx=1.0, dy=1.0)

    # Pattern 5: Short isolated line → separate group
    place_line(start=np.array([3, 3, 0]), count=3)

    return scene

# %% ../nbs/sketching_gestalt_space.ipynb 13
# Create axis-aligned bounding box for a group of cubes
# color them based on their regularity scores
def create_group_aabb(group, regularity_score):
    all_points = np.vstack(
        [
            np.asarray(cube.get_axis_aligned_bounding_box().get_box_points())
            for cube in group
        ]
    )
    aabb = o3d.geometry.AxisAlignedBoundingBox.create_from_points(
        o3d.utility.Vector3dVector(all_points)
    )

    # Color code based on score
    if regularity_score >= 0.8:
        aabb.color = (0.0, 1.0, 0.0)  # Green = regular
    elif regularity_score >= 0.5:
        aabb.color = (1.0, 0.65, 0.0)  # Orange = moderate
    else:
        aabb.color = (1.0, 0.0, 0.0)  # Red = irregular
    return aabb

# %% ../nbs/sketching_gestalt_space.ipynb 15
# Grouping by proximity (Euclidean distance between centers)
def group_by_proximity(cubes, threshold=2.0):
    centers = [cube.get_center() for cube in cubes]
    groups = []
    used = set()
    for i in range(len(cubes)):
        if i in used:
            continue
        group = [cubes[i]]
        used.add(i)
        for j in range(i + 1, len(cubes)):
            if j not in used and np.linalg.norm(centers[i] - centers[j]) < threshold:
                group.append(cubes[j])
                used.add(j)
        groups.append(group)
    return groups

# %% ../nbs/sketching_gestalt_space.ipynb 17
def compute_group_regularity(group):
    if len(group) < 3:
        return 0.0  # too small to assess regularity

    centers = np.array([cube.get_center() for cube in group])
    diffs = []

    for i in range(len(centers)):
        for j in range(i + 1, len(centers)):
            diff = centers[j] - centers[i]
            if np.linalg.norm(diff) > 1e-6:
                diffs.append(diff)

    if len(diffs) < 3:
        return 0.0  # not enough meaningful direction vectors

    diffs = np.array(diffs)
    norm_diffs = np.linalg.norm(diffs, axis=1, keepdims=True)
    unit_dirs = diffs / norm_diffs

    # PCA via covariance matrix of unit directions
    try:
        cov = np.cov(unit_dirs.T)
        eigenvalues, _ = np.linalg.eigh(cov)
        principal_val = eigenvalues[-1]  # largest eigenvalue = dominant direction
        return float(np.clip(principal_val, 0.0, 1.0))  # clip to avoid NaNs
    except np.linalg.LinAlgError:
        return 0.0
